import React, { useState, useEffect, useRef, useCallback, useContext } from 'react';
import type { NodeData } from '../store/useBoardStore';
import { useBoardStore, defaultContent, LIGHT_CARD_COLORS, DARK_CARD_COLORS } from '../store/useBoardStore';
import RichTextEditor from './RichTextEditor';
import CardColorPicker from './CardColorPicker';
import DeleteConfirmModal from './DeleteConfirmModal';
import AICodeGenerator from './AICodeGenerator';
import type { Descendant } from 'slate';
import CodePreview from './CodePreview';
import CodeRenderer from './CodeRenderer';
import { detectCodeLanguage } from '../utils/codeDetector';
import { Transforms, Editor } from 'slate';
import { ReactEditor } from 'slate-react';
import { ThemeContext } from '../App';

// ç®€å•çš„é”™è¯¯è¾¹ç•Œç»„ä»¶
class ErrorBoundary extends React.Component<{children: React.ReactNode, fallback: React.ReactNode}> {
  state = { hasError: false };
  
  static getDerivedStateFromError() {
    return { hasError: true };
  }
  
  componentDidCatch(error: Error) {
    console.error("ç¼–è¾‘å™¨é”™è¯¯:", error);
  }
  
  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }
    return this.props.children;
  }
}

interface Props {
  node: NodeData;
}

// æå–æ–‡æœ¬å†…å®¹çš„è¾…åŠ©å‡½æ•°
const getTextContent = (descendants: any[]): string => {
  if (!descendants || !Array.isArray(descendants)) return '';
  
  return descendants.map(desc => {
    if (desc.children && Array.isArray(desc.children)) {
      return getTextContent(desc.children);
    }
    return desc.text || '';
  }).join('');
};

// æ£€æŸ¥æ˜¯å¦åº”ç§»é™¤å†…è¾¹è·çš„å·¥å…·å‡½æ•°
const shouldRemovePadding = (content: Descendant[]): boolean => {
  // å¦‚æœåªæœ‰ä¸€ä¸ªå…ƒç´ ä¸”æ˜¯å…¨å°ºå¯¸å›¾ç‰‡ï¼Œä¸éœ€è¦å†…è¾¹è·
  if (content.length === 1) {
    const item = content[0] as any;
    return item.type === 'image' && item.isFullSize === true;
  }
  return false;
};

const NodeCard: React.FC<Props> = ({ node }) => {
  const updateNode = useBoardStore((s) => s.updateNode);
  const setNodeEditing = useBoardStore((s) => s.setNodeEditing);
  const selectNode = useBoardStore((s) => s.selectNode);
  const deleteNode = useBoardStore((s) => s.deleteNode);
  const scale = useBoardStore((s) => s.scale);
  const panX = useBoardStore((s) => s.panX);
  const panY = useBoardStore((s) => s.panY);
  
  // æ·»åŠ å¡ç‰‡ç¿»è½¬ç›¸å…³çŠ¶æ€å’Œæ–¹æ³•
  const flipCard = useBoardStore((s) => s.flipCard);
  
  // æ·»åŠ è¿çº¿ç›¸å…³çš„çŠ¶æ€å’Œæ–¹æ³•
  const isConnecting = useBoardStore((s) => s.isConnecting);
  const connectingFrom = useBoardStore((s) => s.connectingFrom);
  const startConnecting = useBoardStore((s) => s.startConnecting);
  const finishConnecting = useBoardStore((s) => s.finishConnecting);
  const addConnection = useBoardStore((s) => s.addConnection);
  const updateTempConnection = useBoardStore((s) => s.updateTempConnection);
  
  // æ·»åŠ CSSåŠ¨ç”»æ ·å¼
  React.useEffect(() => {
    if (!document.getElementById('nodecard-animations')) {
      const style = document.createElement('style');
      style.id = 'nodecard-animations';
      style.textContent = `
        @keyframes slideIn {
          from {
            opacity: 0;
            transform: translateX(10px) scale(0.8);
          }
          to {
            opacity: 1;
            transform: translateX(0) scale(1);
          }
        }
        
        /* æ·»åŠ å¡ç‰‡ç¿»è½¬åŠ¨ç”» */
        .flip-card {
          perspective: 1000px;
          box-sizing: border-box;
          /* ç¡®ä¿è¾¹æ¡†ä½ç½®æ¸…æ™° */
          border: 1px solid transparent;
        }
        
        .flip-card-inner {
          position: relative;
          width: 100%;
          height: 100%;
          transition: transform 0.6s;
          transform-style: preserve-3d;
          box-sizing: border-box;
        }
        
        .flip-card.flipped .flip-card-inner {
          transform: rotateY(180deg);
        }
        
        .flip-card-front, .flip-card-back {
          position: absolute;
          width: 100%;
          height: 100%;
          -webkit-backface-visibility: hidden;
          backface-visibility: hidden;
          overflow: hidden;
          box-sizing: border-box;
        }
        
        .flip-card-back {
          transform: rotateY(180deg);
        }

        /* é”šç‚¹æ‚¬åœåŠ¨ç”» */
        .card-anchor {
          transition: transform 0.2s ease, background-color 0.2s ease, width 0.2s ease, height 0.2s ease; 
        }
        
        .card-anchor:hover {
          transform: scale(1.2);
        }

        /* æ·»åŠ æœ€å¤§é«˜åº¦å’Œæ»šåŠ¨æ¡æ ·å¼ */
        .card-content-container {
          max-height: 550px;
          overflow-y: hidden; /* é»˜è®¤éšè—æº¢å‡º */
          overflow-x: hidden;
          box-sizing: border-box;
          width: 100%;
          height: 100%;
          scrollbar-width: none; /* é»˜è®¤éšè—Firefoxæ»šåŠ¨æ¡ */
        }

        /* å½“å†…å®¹è¶…å‡ºæ—¶æ‰å¯ç”¨æ»šåŠ¨ */
        .card-content-container.content-scrollable {
          overflow-y: auto; /* å†…å®¹è¶…å‡ºæ—¶å¯ç”¨æ»šåŠ¨ */
        }
        
        /* å½“å†…å®¹å¯æ»šåŠ¨å¹¶ä¸”å¡ç‰‡è¢«é€‰ä¸­æˆ–æ‚¬åœæ—¶æ˜¾ç¤ºFirefoxæ»šåŠ¨æ¡ */
        .card-content-container.content-scrollable:hover,
        .card-content-container.content-scrollable:focus,
        .flip-card.selected .card-content-container.content-scrollable {
          scrollbar-width: thin; /* Firefox */
          scrollbar-color: rgba(0, 0, 0, 0.15) transparent; /* Firefox */
        }

        /* ç¼–è¾‘å™¨å®¹å™¨æ ·å¼ */
        .editor-container {
          max-height: 550px;
          overflow-y: auto;
          overflow-x: hidden;
          box-sizing: border-box;
          width: 100%;
          min-height: 100%;
          display: flex;
          flex-direction: column;
          scrollbar-width: none; /* é»˜è®¤éšè—Firefoxæ»šåŠ¨æ¡ */
        }
        
        /* ç¼–è¾‘çŠ¶æ€ä¸‹æ˜¾ç¤ºæ»šåŠ¨æ¡ */
        .flip-card-front:has(.editor-container:focus-within) .editor-container,
        .flip-card-back:has(.editor-container:focus-within) .editor-container,
        .editor-container:hover {
          scrollbar-width: thin; /* Firefox */
          scrollbar-color: rgba(0, 0, 0, 0.15) transparent; /* Firefox */
        }

        /* ç¡®ä¿ç¼–è¾‘å™¨å®¹å™¨è‡³å°‘æœ‰è¶³å¤Ÿçš„é«˜åº¦ */
        .editor-container .slate-editor {
          min-height: 100%;
        }

        /* é»˜è®¤éšè—æ‰€æœ‰æ»šåŠ¨æ¡ */
        .card-content-container::-webkit-scrollbar,
        .editor-container::-webkit-scrollbar {
          width: 4px; /* æ»šåŠ¨æ¡æ›´ç»† */
          display: none; /* é»˜è®¤éšè—æ»šåŠ¨æ¡ */
        }

        /* åªæœ‰å¯æ»šåŠ¨çš„å†…å®¹åœ¨å¡ç‰‡è¢«é€‰ä¸­æˆ–æ‚¬åœæ—¶æ‰æ˜¾ç¤ºæ»šåŠ¨æ¡ */
        .content-scrollable:hover::-webkit-scrollbar,
        .flip-card.selected .content-scrollable::-webkit-scrollbar,
        .editor-container:hover::-webkit-scrollbar,
        .editor-container:focus-within::-webkit-scrollbar {
          display: block; /* æ˜¾ç¤ºæ»šåŠ¨æ¡ */
        }

        .card-content-container::-webkit-scrollbar-track,
        .editor-container::-webkit-scrollbar-track {
          background: transparent;
          margin: 4px 0; /* ä¸Šä¸‹ç•™å‡ºç©ºé—´ */
        }

        .card-content-container::-webkit-scrollbar-thumb,
        .editor-container::-webkit-scrollbar-thumb {
          background: rgba(0, 0, 0, 0.15); /* æ›´æ·¡çš„é¢œè‰² */
          border-radius: 4px; /* åœ†è§’æ›´å¤§ */
        }

        .card-content-container::-webkit-scrollbar-thumb:hover,
        .editor-container::-webkit-scrollbar-thumb:hover {
          background: rgba(0, 0, 0, 0.25); /* æ‚¬åœæ—¶ç¨å¾®æ·±ä¸€ç‚¹ */
        }
      `;
      document.head.appendChild(style);
    }
  }, []);
  
  const [dragging, setDragging] = useState(false);
  const [resizing, setResizing] = useState(false);
  const [showColorPicker, setShowColorPicker] = useState(false);
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [showActionMenu, setShowActionMenu] = useState(false);
  const [showAIGenerator, setShowAIGenerator] = useState(false);
  const [aiGeneratorPosition, setAIGeneratorPosition] = useState({ x: 0, y: 0 });
  const [colorPickerPosition, setColorPickerPosition] = useState({ x: 0, y: 0 });
  
  // æ–°å¢æœ¬åœ°å†…å®¹çŠ¶æ€
  const [localContent, setLocalContent] = useState<Descendant[]>(() => {
    if (node.isFlipped) {
      return (node.backContent && Array.isArray(node.backContent) && node.backContent.length > 0)
        ? node.backContent : defaultContent;
    } else {
      return (node.frontContent && Array.isArray(node.frontContent) && node.frontContent.length > 0)
        ? node.frontContent : (node.content && Array.isArray(node.content) && node.content.length > 0)
          ? node.content : defaultContent;
    }
  });
  
  // åªæœ‰å¤–éƒ¨ node å†…å®¹å˜åŒ–æ—¶æ‰åŒæ­¥ localContent
  useEffect(() => {
    const external = node.isFlipped
      ? (node.backContent && Array.isArray(node.backContent) && node.backContent.length > 0)
        ? node.backContent : defaultContent
      : (node.frontContent && Array.isArray(node.frontContent) && node.frontContent.length > 0)
        ? node.frontContent : (node.content && Array.isArray(node.content) && node.content.length > 0)
          ? node.content : defaultContent;
    if (JSON.stringify(external) !== JSON.stringify(localContent)) {
      setLocalContent(external);
    }
  }, [node.frontContent, node.backContent, node.content, node.isFlipped]);
  
  // ä½¿ç”¨refä¿å­˜æœ€æ–°çš„ç¼–è¾‘å™¨å†…å®¹
  const currentContentRef = useRef<Descendant[]>(localContent);
  // ä½¿ç”¨refæ¥è·Ÿè¸ªå¡ç‰‡å…ƒç´ ï¼Œç”¨äºè·å–å®æ—¶é«˜åº¦
  const cardRef = useRef<HTMLDivElement>(null);
  // æ·»åŠ Slateç¼–è¾‘å™¨çš„ref
  const slateEditorRef = useRef<ReactEditor | null>(null);
  
  // æ›´æ–°refä¸­çš„å†…å®¹
  useEffect(() => {
    currentContentRef.current = localContent;
  }, [localContent]);

  // ç›‘å¬ç¼–è¾‘çŠ¶æ€å˜åŒ–ï¼Œç¡®ä¿å†…å®¹ä¸ä¸¢å¤±
  const [prevEditing, setPrevEditing] = useState(node.editing);
  
  // ä»£ç æ£€æµ‹çŠ¶æ€
  // const [isCodeMode, setIsCodeMode] = useState(false);
  // const [codeContent, setCodeContent] = useState('');
  // const [codeLanguage, setCodeLanguage] = useState('javascript');
  
  useEffect(() => {
    // æ£€æµ‹ä»ç¼–è¾‘çŠ¶æ€å˜ä¸ºéç¼–è¾‘çŠ¶æ€
    if (prevEditing && !node.editing) {
      // ç«‹å³ä¿å­˜å½“å‰ç¼–è¾‘å™¨å†…å®¹
      const contentToSave = currentContentRef.current;
      if (contentToSave && Array.isArray(contentToSave) && contentToSave.length > 0) {
        // æ£€æŸ¥æ˜¯å¦æœ‰å›¾ç‰‡ä¸”ä¸ºisFullSizeæ¨¡å¼
        const hasFullSizeImage = contentToSave.some((item: any) => 
          item.type === 'image' && item.isFullSize === true
        );
        
        // æ£€æŸ¥æ˜¯å¦æœ‰æ–‡æœ¬å†…å®¹
        const hasTextContent = contentToSave.some((item: any) => {
          if (item.type === 'paragraph' && item.children && Array.isArray(item.children)) {
            return item.children.some((child: any) => child.text && child.text.trim() !== '');
          }
          return false;
        });
        
        // é’ˆå¯¹ä»…æœ‰å…¨å°ºå¯¸å›¾ç‰‡çš„æƒ…å†µç‰¹æ®Šå¤„ç†
        if (hasFullSizeImage && !hasTextContent && contentToSave.length === 1) {
          // ç¡®ä¿å¡ç‰‡æ— å†…è¾¹è·
          if (node.isFlipped) {
            console.log('ä¿å­˜å¡ç‰‡èƒŒé¢å†…å®¹ï¼ˆå…¨å°ºå¯¸å›¾ç‰‡ï¼‰', contentToSave);
            updateNode(node.id, { 
              backContent: contentToSave,
              // ç¡®ä¿å†…å®¹ä¹ŸåŒæ—¶æ›´æ–°åˆ°å…¨å±€contentä¸­ï¼Œé¿å…æ­£é¢å†…å®¹ä¸¢å¤±
              content: node.frontContent || contentToSave
            });
          } else {
            updateNode(node.id, { 
              frontContent: contentToSave,
              content: contentToSave
            });
          }
        } else {
          // å¸¸è§„æƒ…å†µå¤„ç†
          const hasContent = contentToSave.some((item: any) => 
            item.children && Array.isArray(item.children) && 
            item.children.some((child: any) => child.text && child.text.trim() !== '')
          );
          
          if (hasContent || JSON.stringify(contentToSave) !== JSON.stringify(defaultContent)) {
            // æ ¹æ®å½“å‰å¡ç‰‡é¢æ›´æ–°ç›¸åº”çš„å†…å®¹
            if (node.isFlipped) {
              console.log('ä¿å­˜å¡ç‰‡èƒŒé¢å†…å®¹', contentToSave);
              // åŒæ—¶æ›´æ–°backContentå’Œå…¨å±€contentï¼Œç¡®ä¿å†…å®¹ä¸ä¸¢å¤±
              updateNode(node.id, { 
                backContent: contentToSave,
                // ç¡®ä¿å†…å®¹ä¹ŸåŒæ—¶æ›´æ–°åˆ°å…¨å±€contentä¸­ï¼Œé¿å…æ­£é¢å†…å®¹ä¸¢å¤± 
                content: node.frontContent || contentToSave
              });
            } else {
              updateNode(node.id, { 
                frontContent: contentToSave,
                content: contentToSave // åŒæ—¶æ›´æ–°contentä»¥ä¿æŒå‘åå…¼å®¹
              });
            }
          }
        }
      }
    }
    
    // è¿›å…¥ç¼–è¾‘çŠ¶æ€æ—¶ç¡®ä¿isCodeModeä¸ºfalse
    // if (!prevEditing && node.editing) {
    //   setIsCodeMode(false);
    // }
    
    setPrevEditing(node.editing);
  }, [node.editing, prevEditing, updateNode, node.id, node.isFlipped, node.frontContent]);

  // å…¨å±€ç‚¹å‡»ç›‘å¬ï¼Œå½“ç‚¹å‡»å¡ç‰‡å¤–éƒ¨æ—¶é€€å‡ºç¼–è¾‘çŠ¶æ€å’Œå…³é—­èœå•
  useEffect(() => {
    if (!node.editing && !showActionMenu) return;

    const handleGlobalClick = (e: MouseEvent) => {
      // å¦‚æœç‚¹å‡»çš„æ˜¯å½“å‰å¡ç‰‡å†…éƒ¨ï¼Œä¸åšä»»ä½•å¤„ç†
      const cardElement = e.target as Element;
      let isClickInside = false;
      
      // æ£€æŸ¥ç‚¹å‡»æ˜¯å¦åœ¨å½“å‰å¡ç‰‡å†…
      let current = cardElement;
      while (current && current !== document.body) {
        if (current.closest && current.closest(`[data-node-id="${node.id}"]`)) {
          isClickInside = true;
          break;
        }
        current = current.parentElement as Element;
      }
      
      // å¦‚æœç‚¹å‡»åœ¨å¡ç‰‡å¤–éƒ¨
      if (!isClickInside) {
        // å…³é—­åŠ¨ä½œèœå•
        if (showActionMenu) {
          setShowActionMenu(false);
        }
        
        // å¦‚æœåœ¨ç¼–è¾‘çŠ¶æ€ï¼Œé€€å‡ºç¼–è¾‘
        if (node.editing) {
          // ä¿å­˜å½“å‰ç¼–è¾‘å†…å®¹å’Œè°ƒæ•´é«˜åº¦
          const validContent = (currentContentRef.current && Array.isArray(currentContentRef.current) && currentContentRef.current.length > 0) ? 
            currentContentRef.current : 
            defaultContent;
          
          // åœ¨é€€å‡ºç¼–è¾‘å‰ï¼Œæ£€æŸ¥å†…å®¹æ˜¯å¦éœ€è¦æ›´å¤§çš„é«˜åº¦
          if (cardRef.current) {
            const contentHeight = getContentHeight();
            const currentHeight = node.height || 80;
            
            // å¦‚æœå†…å®¹é«˜åº¦å¤§äºå½“å‰é«˜åº¦ï¼Œåˆ™æ‰©å±•å¡ç‰‡é«˜åº¦
            // ä½†åŒæ—¶ç¡®ä¿ä¸è¶…è¿‡æœ€å¤§é«˜åº¦é™åˆ¶
            const newHeight = Math.min(550, Math.max(currentHeight, contentHeight));
            
            // æ ¹æ®å½“å‰æ˜¯å¦ä¸ºç¿»è½¬çŠ¶æ€ï¼Œä¿å­˜å¯¹åº”å†…å®¹
            if (node.isFlipped) {
              console.log('ç‚¹å‡»å¤–éƒ¨ä¿å­˜èƒŒé¢å†…å®¹', validContent);
              // åŒæ—¶ä¿å­˜å†…å®¹å’Œé«˜åº¦
              updateNode(node.id, { 
                backContent: validContent,
                // ç¡®ä¿å†…å®¹ä¹ŸåŒæ—¶æ›´æ–°åˆ°å…¨å±€contentä¸­ï¼Œé¿å…æ­£é¢å†…å®¹ä¸¢å¤±
                content: node.frontContent || validContent,
                ...((!!node.userResized) ? {} : { height: newHeight })
              });
            } else {
              // åŒæ—¶ä¿å­˜å†…å®¹å’Œé«˜åº¦
              updateNode(node.id, { 
                frontContent: validContent,
                content: validContent,
                ...((!!node.userResized) ? {} : { height: newHeight })
              });
            }
          } else {
            // å¦‚æœæ²¡æœ‰cardRefï¼Œè‡³å°‘ä¿å­˜å†…å®¹
            if (node.isFlipped) {
              console.log('ç‚¹å‡»å¤–éƒ¨ä¿å­˜èƒŒé¢å†…å®¹ï¼ˆæ— é«˜åº¦è°ƒæ•´ï¼‰', validContent);
              updateNode(node.id, { 
                backContent: validContent,
                // ç¡®ä¿å†…å®¹ä¹ŸåŒæ—¶æ›´æ–°åˆ°å…¨å±€contentä¸­ï¼Œé¿å…æ­£é¢å†…å®¹ä¸¢å¤±
                content: node.frontContent || validContent
              });
            } else {
              updateNode(node.id, { 
                frontContent: validContent,
                content: validContent
              });
            }
          }
          
          // å»¶è¿Ÿä¸€å¸§å†é€€å‡ºç¼–è¾‘çŠ¶æ€ï¼Œç¡®ä¿å†…å®¹å’Œé«˜åº¦å·²ç»ä¿å­˜
          setTimeout(() => {
            setNodeEditing(node.id, false);
          }, 0);
        }
      }
    };

    // æ·»åŠ å…¨å±€ç‚¹å‡»ç›‘å¬
    document.addEventListener('mousedown', handleGlobalClick, true);
    
    return () => {
      document.removeEventListener('mousedown', handleGlobalClick, true);
    };
  }, [node.editing, showActionMenu, node.id, setNodeEditing, node.isFlipped, node.frontContent, node.height, updateNode]);

  const { isDarkMode } = useContext(ThemeContext);
  const colorList = isDarkMode ? DARK_CARD_COLORS : LIGHT_CARD_COLORS;
  // è·å–å½“å‰èƒŒæ™¯è‰²é…ç½®
  const getCurrentCardBackground = () => {
    let colorId = isDarkMode ? node.darkBackgroundColor : node.lightBackgroundColor;
    // å…¼å®¹è€æ•°æ®
    if (!colorId) colorId = node.backgroundColor;
    // æ²¡æœ‰åˆ™ç”¨ç¬¬0ä¸ª
    const idx = colorList.findIndex(c => c.id === colorId);
    return colorList[idx >= 0 ? idx : 0];
  };
  const currentBg = getCurrentCardBackground();

  // å³é”®èœå•å¤„ç†
  const handleContextMenu = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    
    if (node.editing) return;

    // è®¾ç½®é¢œè‰²é€‰æ‹©å™¨ä½ç½®
    setColorPickerPosition({ x: e.clientX, y: e.clientY });
    setShowColorPicker(true);
  };

  // é¢œè‰²å˜åŒ–å¤„ç†
  const handleColorChange = (colorId: string) => {
    if (isDarkMode) {
      updateNode(node.id, { darkBackgroundColor: colorId });
    } else {
      updateNode(node.id, { lightBackgroundColor: colorId });
    }
  };

  const handleConfirmDelete = () => {
    deleteNode(node.id);
    setShowDeleteModal(false);
  };

  // ç‚¹å‡»å¤„ç† - ç¡®ä¿å•å‡»èƒ½é€‰ä¸­
  const handleClick = (e: React.MouseEvent) => {
    if (node.editing || showColorPicker || showDeleteModal) return;
    
    e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡åˆ°BoardCanvas
    
    // å¦‚æœå½“å‰åœ¨è¿çº¿æ¨¡å¼ï¼Œå¤„ç†è¿çº¿é€»è¾‘
    if (isConnecting) {
      if (connectingFrom === node.id) {
        // ç‚¹å‡»äº†åŒä¸€ä¸ªèŠ‚ç‚¹ï¼Œå–æ¶ˆè¿çº¿
        finishConnecting();
        return;
      } else if (connectingFrom) {
        // å®Œæˆè¿çº¿åˆ°ç›®æ ‡èŠ‚ç‚¹
        addConnection(connectingFrom, node.id);
        finishConnecting();
        return;
      }
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–æ­£åœ¨ç¼–è¾‘çš„èŠ‚ç‚¹ï¼Œå¦‚æœæœ‰åˆ™å…ˆä¿å­˜å¹¶é€€å‡ºç¼–è¾‘çŠ¶æ€
    const allNodes = useBoardStore.getState().nodes;
    const editingNode = allNodes.find(n => n.editing && n.id !== node.id);
    if (editingNode) {
      const { setNodeEditing } = useBoardStore.getState();
      setNodeEditing(editingNode.id, false);
    }
    
    // å¤„ç†é€‰ä¸­çŠ¶æ€
    const isMultiSelect = e.metaKey || e.ctrlKey;
    selectNode(node.id, isMultiSelect);
  };

  // è¿çº¿æŒ‰é’®ç‚¹å‡»å¤„ç† - æš‚æ—¶æœªä½¿ç”¨
  /*
  const handleConnectClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    
    // å¦‚æœå½“å‰æ­£åœ¨ç¼–è¾‘ï¼Œå…ˆä¿å­˜ç¼–è¾‘å†…å®¹
    if (node.editing) {
      const validContent = (currentContentRef.current && Array.isArray(currentContentRef.current) && currentContentRef.current.length > 0) ? currentContentRef.current : defaultContent;
      updateNode(node.id, { frontContent: validContent, backContent: validContent });
      setNodeEditing(node.id, false);
    }
    
    // å¼€å§‹è¿çº¿
    startConnecting(node.id);
    setShowActionMenu(false);
  };
  */

  // é”šç‚¹æ‹–æ‹½å¼€å§‹
  const handleAnchorMouseDown = (e: React.MouseEvent, position: 'top' | 'right' | 'bottom' | 'left') => {
    e.stopPropagation();
    e.preventDefault();
    
    // å¦‚æœå½“å‰æ­£åœ¨ç¼–è¾‘ï¼Œå…ˆä¿å­˜ç¼–è¾‘å†…å®¹
    if (node.editing) {
      const validContent = (currentContentRef.current && Array.isArray(currentContentRef.current) && currentContentRef.current.length > 0) ? currentContentRef.current : defaultContent;
      updateNode(node.id, { frontContent: validContent, backContent: validContent });
      setNodeEditing(node.id, false);
    }
    
    // æ£€æµ‹ç›®æ ‡é”šç‚¹ä½ç½®çš„è¾…åŠ©å‡½æ•°
    const detectTargetAnchor = (clientX: number, clientY: number, targetElement: HTMLElement): 'top' | 'right' | 'bottom' | 'left' => {
      const flipCardElement = targetElement.closest('.flip-card') as HTMLElement;
      const rect = flipCardElement ? flipCardElement.getBoundingClientRect() : targetElement.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      // è®¡ç®—é¼ æ ‡ä½ç½®ç›¸å¯¹äºå¡ç‰‡ä¸­å¿ƒçš„åç§»
      const offsetX = clientX - centerX;
      const offsetY = clientY - centerY;
      
      // æ ¹æ®åç§»é‡ç¡®å®šæœ€è¿‘çš„é”šç‚¹
      if (Math.abs(offsetX) > Math.abs(offsetY)) {
        return offsetX > 0 ? 'right' : 'left';
      } else {
        return offsetY > 0 ? 'bottom' : 'top';
      }
    };
    
    // è®¡ç®—é”šç‚¹çš„ç²¾ç¡®å±å¹•åæ ‡
    const getAnchorScreenPosition = (position: string) => {
      const flipCardElement = cardRef.current;
      if (!flipCardElement) return { x: e.clientX, y: e.clientY };
      
      const rect = flipCardElement.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      switch (position) {
        case 'top':
          return { x: centerX, y: rect.top };
        case 'right':
          return { x: rect.right, y: centerY };
        case 'bottom':
          return { x: centerX, y: rect.bottom };
        case 'left':
          return { x: rect.left, y: centerY };
        default:
          return { x: centerX, y: centerY };
      }
    };
    
    // å¼€å§‹è¿çº¿ï¼Œå¹¶è®¾ç½®åˆå§‹ä½ç½®ä¸ºé”šç‚¹ä½ç½®
    startConnecting(node.id, position);
    const anchorPos = getAnchorScreenPosition(position);
    updateTempConnection(anchorPos.x, anchorPos.y);
    
    // ç«‹å³å¼€å§‹è·Ÿè¸ªé¼ æ ‡ç§»åŠ¨
    const onMouseMove = (e: MouseEvent) => {
      updateTempConnection(e.clientX, e.clientY);
    };
    
    const onMouseUp = (e: MouseEvent) => {
      // æ£€æŸ¥æ˜¯å¦æ¾å¼€é¼ æ ‡åœ¨å¦ä¸€ä¸ªå¡ç‰‡ä¸Š
      const element = document.elementFromPoint(e.clientX, e.clientY);
      const targetCard = element?.closest('[data-node-id]');
      
      if (targetCard) {
        const targetNodeId = targetCard.getAttribute('data-node-id');
        
        if (targetNodeId && targetNodeId !== node.id) {
          // æ£€æµ‹ç›®æ ‡é”šç‚¹ä½ç½®
          const targetAnchor = detectTargetAnchor(e.clientX, e.clientY, targetCard as HTMLElement);
          // ä½¿ç”¨ finishConnecting å¹¶ä¼ é€’ç›®æ ‡èŠ‚ç‚¹IDå’Œé”šç‚¹ä½ç½®
          finishConnecting(targetNodeId, targetAnchor);
        } else {
          // å¦‚æœç›®æ ‡æ˜¯åŒä¸€å¼ å¡ç‰‡ï¼Œç›´æ¥å–æ¶ˆè¿çº¿
          finishConnecting();
        }
      } else {
        // æ²¡æœ‰ç›®æ ‡å¡ç‰‡æ—¶å–æ¶ˆè¿çº¿
        finishConnecting();
      }
      
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    };
    
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
  };

  // æ‹–æ‹½é€»è¾‘
  const onMouseDown = (e: React.MouseEvent) => {
    if (node.editing || showColorPicker || showDeleteModal) return;
    
    e.stopPropagation();
    e.preventDefault();
    
    const startX = e.clientX;
    const startY = e.clientY;
    let hasDragged = false;
    let lastX = startX;
    let lastY = startY;
    
    const onMouseMove = (e: MouseEvent) => {
      const deltaX = e.clientX - lastX;
      const deltaY = e.clientY - lastY;
      
      // å¦‚æœç§»åŠ¨è·ç¦»è¶…è¿‡é˜ˆå€¼ï¼Œå¼€å§‹æ‹–æ‹½
      if (!hasDragged && (Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5)) {
        hasDragged = true;
    setDragging(true);
        
        // å¼€å§‹æ‹–æ‹½æ—¶ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–æ­£åœ¨ç¼–è¾‘çš„èŠ‚ç‚¹
        const allNodes = useBoardStore.getState().nodes;
        const editingNode = allNodes.find(n => n.editing && n.id !== node.id);
        if (editingNode) {
          const { setNodeEditing } = useBoardStore.getState();
          setNodeEditing(editingNode.id, false);
        }
        
        // å¦‚æœå½“å‰å¡ç‰‡æœªé€‰ä¸­ï¼Œæˆ–è€…æ˜¯å¤šé€‰æ¨¡å¼ï¼Œå¤„ç†é€‰ä¸­çŠ¶æ€
        const isMultiSelect = e.metaKey || e.ctrlKey;
        if (!node.selected || isMultiSelect) {
          selectNode(node.id, isMultiSelect);
        }
      }
      
      if (!hasDragged) return;
      
      // è·å–å½“å‰çŠ¶æ€
      const currentNodes = useBoardStore.getState().nodes;
      const currentSelectedNodes = useBoardStore.getState().selectedNodes;
      
      // ç§»åŠ¨æ‰€æœ‰é€‰ä¸­çš„èŠ‚ç‚¹ï¼ˆä½¿ç”¨å¢é‡ç§»åŠ¨ï¼‰
      currentSelectedNodes.forEach(nodeId => {
        const targetNode = currentNodes.find(n => n.id === nodeId);
        if (!targetNode) return;
        
        if (targetNode.pinned) {
          // å›ºå®šå¡ç‰‡ç›´æ¥ä½¿ç”¨å±å¹•åæ ‡ç§»åŠ¨
          const currentPinnedX = targetNode.pinnedX || 100;
          const currentPinnedY = targetNode.pinnedY || 100;
          updateNode(nodeId, {
            pinnedX: currentPinnedX + deltaX,
            pinnedY: currentPinnedY + deltaY,
          });
        } else {
          // æ™®é€šå¡ç‰‡éœ€è¦è€ƒè™‘ç¼©æ”¾å› å­
          const currentX = targetNode.x;
          const currentY = targetNode.y;
          updateNode(nodeId, {
            x: currentX + deltaX / scale,
            y: currentY + deltaY / scale,
          });
        }
      });
      
      // æ›´æ–°ä¸Šæ¬¡çš„é¼ æ ‡ä½ç½®
      lastX = e.clientX;
      lastY = e.clientY;
    };

    const onMouseUp = (e: MouseEvent) => {
      // å¦‚æœæ²¡æœ‰æ‹–æ‹½ï¼Œè§¦å‘ç‚¹å‡»é€‰ä¸­é€»è¾‘
      if (!hasDragged) {
        // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–æ­£åœ¨ç¼–è¾‘çš„èŠ‚ç‚¹
        const allNodes = useBoardStore.getState().nodes;
        const editingNode = allNodes.find(n => n.editing && n.id !== node.id);
        if (editingNode) {
          const { setNodeEditing } = useBoardStore.getState();
          setNodeEditing(editingNode.id, false);
        }
        
        // å¤„ç†é€‰ä¸­çŠ¶æ€
        const isMultiSelect = (e as any).metaKey || (e as any).ctrlKey;
        selectNode(node.id, isMultiSelect);
      }
      
      setDragging(false);
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
    };

    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
  };

  // ç¼–è¾‘æ€åˆ‡æ¢æ—¶åŒæ­¥å†…å®¹
  useEffect(() => {
    // åŒæ­¥ç¼–è¾‘å™¨å†…å®¹ - åªåœ¨è¿›å…¥ç¼–è¾‘æ¨¡å¼æ—¶æ›´æ–°ï¼Œé¿å…ç¼–è¾‘è¿‡ç¨‹ä¸­è¢«é‡ç½®
    if (node.editing) {
      console.log('è¿›å…¥ç¼–è¾‘æ¨¡å¼ï¼ŒåŠ è½½å†…å®¹', node.isFlipped ? 'èƒŒé¢' : 'æ­£é¢');
      // æ ¹æ®å½“å‰æ˜¯æ­£é¢è¿˜æ˜¯èƒŒé¢ï¼ŒåŠ è½½å¯¹åº”çš„å†…å®¹
      if (node.isFlipped) {
        // ç¡®ä¿åŠ è½½èƒŒé¢å†…å®¹
        const backContentToLoad = (node.backContent && Array.isArray(node.backContent) && node.backContent.length > 0)
          ? node.backContent
          : defaultContent;
        
        // æ›´æ–°åˆ°refå’Œstate
        currentContentRef.current = backContentToLoad;
        console.log('æ›´æ–°èƒŒé¢ç¼–è¾‘å™¨å†…å®¹', backContentToLoad);
      } else {
        // åŠ è½½æ­£é¢å†…å®¹
        const frontContentToLoad = (node.frontContent && Array.isArray(node.frontContent) && node.frontContent.length > 0)
          ? node.frontContent
          : (node.content && Array.isArray(node.content) && node.content.length > 0)
            ? node.content
            : defaultContent;
        
        // æ›´æ–°åˆ°refå’Œstate
        currentContentRef.current = frontContentToLoad;
        console.log('æ›´æ–°æ­£é¢ç¼–è¾‘å™¨å†…å®¹', frontContentToLoad);
      }
    }
  }, [node.editing, node.isFlipped, node.frontContent, node.backContent, node.content]); // æ·»åŠ isFlippedä¾èµ–ï¼Œç¡®ä¿ç¿»è½¬æ—¶èƒ½å¤Ÿæ›´æ–°å†…å®¹

  // åŒå‡»è¿›å…¥ç¼–è¾‘æ€
  const [pendingFocusPos, setPendingFocusPos] = useState<{x: number, y: number} | null>(null);
  const handleDoubleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    setShowColorPicker(false);
    setShowDeleteModal(false);
    // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–æ­£åœ¨ç¼–è¾‘çš„èŠ‚ç‚¹ï¼Œå¦‚æœæœ‰åˆ™å…ˆä¿å­˜å¹¶é€€å‡ºç¼–è¾‘çŠ¶æ€
    const allNodes = useBoardStore.getState().nodes;
    const editingNode = allNodes.find(n => n.editing && n.id !== node.id);
    if (editingNode) {
      const { setNodeEditing } = useBoardStore.getState();
      setNodeEditing(editingNode.id, false);
    }
    // è®°å½•é¼ æ ‡åæ ‡
    setPendingFocusPos({ x: e.clientX, y: e.clientY });
    setNodeEditing(node.id, true);
  };

  // ä¿å­˜å†…å®¹å¹¶é€€å‡ºç¼–è¾‘æ€
  const finishEdit = () => {
    const validContent = (currentContentRef.current && Array.isArray(currentContentRef.current) && currentContentRef.current.length > 0) ? currentContentRef.current : defaultContent;
    if (cardRef.current) {
      const contentHeight = getContentHeight();
      const currentHeight = node.height || 80;
      const newHeight = Math.min(550, Math.max(currentHeight, contentHeight));
      if (node.isFlipped) {
        updateNode(node.id, { backContent: validContent, ...((!!node.userResized) ? {} : { height: newHeight }) });
      } else {
        updateNode(node.id, { frontContent: validContent, content: validContent, ...((!!node.userResized) ? {} : { height: newHeight }) });
      }
    } else {
      if (node.isFlipped) {
        updateNode(node.id, { backContent: validContent });
      } else {
        updateNode(node.id, { frontContent: validContent, content: validContent });
      }
    }
    setNodeEditing(node.id, false);
  };

  // å¤„ç†ç¼–è¾‘å™¨å†…å®¹å˜åŒ–
  const handleEditorChange = (value: Descendant[]) => {
    currentContentRef.current = value;
    
    // æ£€æµ‹å¹¶å¤„ç†æ ‡ç­¾è¾“å…¥
    const textContent = getTextContent(value);
    const tagMatches = textContent.match(/#([^\s#]+)/g);
    
    if (tagMatches) {
      // æ·»åŠ æ ‡ç­¾
      tagMatches.forEach(match => {
        const tagName = match.slice(1).trim(); // ç§»é™¤ # å·
        if (tagName) {
          addTag(tagName);
        }
      });
      
      // æ¸…é™¤æ ‡ç­¾æ–‡æœ¬ï¼Œåˆ›å»ºæ–°çš„å†…å®¹
      const cleanedContent = value.map(block => {
        if ((block as any).type === 'paragraph' && (block as any).children) {
          const cleanedChildren = (block as any).children.map((child: any) => {
            if (child.text) {
              return {
                ...child,
                text: child.text.replace(/#[^\s#]+/g, '').trim()
              };
            }
            return child;
          });
          
          return {
            ...block,
            children: cleanedChildren
          };
        }
        return block;
      }).filter(block => {
        // è¿‡æ»¤æ‰ç©ºçš„æ®µè½
        if ((block as any).type === 'paragraph' && (block as any).children) {
          const hasContent = (block as any).children.some((child: any) => 
            child.text && child.text.trim() !== ''
          );
          return hasContent;
        }
        return true;
      });
      
      // å¦‚æœæ¸…ç†åæ²¡æœ‰å†…å®¹ï¼Œæ·»åŠ ä¸€ä¸ªç©ºæ®µè½
      const finalContent = cleanedContent.length === 0 ? 
        [{ type: 'paragraph', children: [{ text: '' }] }] : 
        cleanedContent;
      
      // æ›´æ–°å†…å®¹ï¼ˆä¸åŒ…å«æ ‡ç­¾æ–‡æœ¬ï¼‰
      currentContentRef.current = finalContent as Descendant[];
      if (node.isFlipped) {
        updateNode(node.id, { backContent: finalContent as Descendant[] });
      } else {
        updateNode(node.id, { frontContent: finalContent as Descendant[], content: finalContent as Descendant[] });
      }
      
      return; // æ—©æœŸè¿”å›ï¼Œé¿å…é‡å¤æ›´æ–°
    }
    
    // æ­£å¸¸çš„å†…å®¹æ›´æ–°
    if (node.isFlipped) {
      updateNode(node.id, { backContent: value });
    } else {
                      // å–æ¶ˆå›ºå®š
                      const currentScreenX = node.pinnedX || 100;
                      const currentScreenY = node.pinnedY || 100;
                      const worldX = (currentScreenX - panX) / scale;
                      const worldY = (currentScreenY - panY) / scale;
                      updateNode(node.id, { 
                        x: worldX, 
                        y: worldY,
                        pinned: false, // ç›´æ¥è®¾ç½®pinnedçŠ¶æ€
                        pinnedX: undefined, // æ¸…é™¤å›ºå®šåæ ‡
                        pinnedY: undefined
                      });
                    }
                    setShowActionMenu(false);
                  }}
                  style={{
                    position: 'absolute',
                    top: -32, // ä¸ä¸»æŒ‰é’®åŒä¸€æ°´å¹³çº¿
                    right: 68, // å‘å·¦åç§»æ›´å¤š
                    width: 28,
                    height: 28,
                    borderRadius: 14,
                    border: `2px solid #ffffff`,
                    background: '#ffffff', // ç™½è‰²èƒŒæ™¯
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    boxShadow: `0 3px 12px rgba(0,0,0,0.15)`, // å¢å¼ºé˜´å½±
                    transition: 'all 0.3s ease',
                    animation: 'slideIn 0.2s ease-out 0.05s both',
                    zIndex: 998, // é«˜z-index
                  }}
                  onMouseEnter={(e) => {
                    e.currentTarget.style.transform = 'scale(1.1)';
                    e.currentTarget.style.boxShadow = '0 4px 16px rgba(0,0,0,0.2)';
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.transform = 'scale(1)';
                    e.currentTarget.style.boxShadow = '0 3px 12px rgba(0,0,0,0.15)';
                  }}
                  title={node.pinned ? "å–æ¶ˆå›ºå®š" : "å›ºå®šä½ç½®"}
                >
                  {/* ğŸ“Œå›¾é’‰æ ·å¼å›¾æ ‡ */}
                  <svg
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="currentColor"
                    style={{
                      color: '#dc2626',
                    }}
                  >
                    <path d="M16,12V4A1,1 0 0,0 15,3H9A1,1 0 0,0 8,4V12L6,14V16H11V21.5C11,21.78 11.22,22 11.5,22A0.5,0.5 0 0,0 12,21.5V16H17V14L16,12Z" />
                  </svg>
                </button>

                {/* åˆ é™¤æŒ‰é’® */}
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    setShowDeleteModal(true);
                    setShowActionMenu(false);
                  }}
                  style={{
                    position: 'absolute',
                    top: -32, // ä¸ä¸»æŒ‰é’®åŒä¸€æ°´å¹³çº¿
                    right: 100, // å‘å·¦åç§»æœ€å¤š
                    width: 28, // ç¨å¾®å¢å¤§ä¸€ç‚¹
                    height: 28,
                    borderRadius: 14,
                    border: `2px solid #ffffff`,
                    background: '#ef4444',
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    boxShadow: `0 3px 12px rgba(239,68,68,0.3)`, // çº¢è‰²é˜´å½±
                    transition: 'all 0.3s ease',
                    animation: 'slideIn 0.2s ease-out 0.1s both',
                    zIndex: 997, // é«˜z-index
                  }}
                  onMouseEnter={(e) => {
                    e.currentTarget.style.transform = 'scale(1.1)';
                    e.currentTarget.style.background = '#dc2626';
                    e.currentTarget.style.boxShadow = '0 4px 16px rgba(220,38,38,0.4)';
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.transform = 'scale(1)';
                    e.currentTarget.style.background = '#ef4444';
                    e.currentTarget.style.boxShadow = '0 3px 12px rgba(239,68,68,0.3)';
                  }}
                  title="åˆ é™¤å¡ç‰‡"
                >
                  {/* åƒåœ¾æ¡¶SVGå›¾æ ‡ - æ›´æ¸…æ™°çš„è®¾è®¡ */}
                  <svg
                    width="12"
                    height="12"
                    viewBox="0 0 16 16"
                    fill="none"
                  >
                    <path
                      d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"
                      fill="#ffffff"
                    />
                    <path
                      d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1-1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"
                      fill="#ffffff"
                    />
                  </svg>
                </button>

                {/* æ·»åŠ ç¿»è½¬æŒ‰é’® - ä½¿ç”¨A/Bç¬¦å·è®¾è®¡ */}
                <button
                  onClick={handleFlipCard}
                  style={{
                    position: 'absolute',
                    top: -32,
                    right: 132, // ä½ç½®è°ƒæ•´ï¼Œç°åœ¨è¿çº¿æŒ‰é’®å·²è¢«ç§»é™¤
                    width: 28,
                    height: 28,
                    borderRadius: 14,
                    border: `2px solid #ffffff`,
                    background: '#8b5cf6', // ç´«è‰²èƒŒæ™¯
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    boxShadow: `0 3px 12px rgba(139,92,246,0.3)`, // ç´«è‰²é˜´å½±
                    transition: 'all 0.3s ease',
                    animation: 'slideIn 0.2s ease-out 0.05s both',
                    zIndex: 999,
                  }}
                  onMouseEnter={(e) => {
                    e.currentTarget.style.transform = 'scale(1.1)';
                    e.currentTarget.style.boxShadow = '0 4px 16px rgba(139,92,246,0.4)';
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.transform = 'scale(1)';
                    e.currentTarget.style.boxShadow = '0 3px 12px rgba(139,92,246,0.3)';
                  }}
                  title="ç¿»è½¬å¡ç‰‡"
                >
                  {/* ä½¿ç”¨A/Bç¿»è½¬å›¾æ ‡ */}
                  <div style={{
                    position: 'relative',
                    width: 18,
                    height: 18,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                  }}>
                    <span style={{
                      position: 'absolute',
                      fontSize: 10,
                      fontWeight: 'bold',
                      color: '#ffffff',
                      transform: 'translateX(-4px)',
                    }}>
                      A
                    </span>
                    <span style={{
                      position: 'absolute',
                      fontSize: 10,
                      fontWeight: 'bold',
                      color: '#ffffff',
                      transform: 'rotate(25deg)',
                    }}>
                      /
                    </span>
                    <span style={{
                      position: 'absolute',
                      fontSize: 10,
                      fontWeight: 'bold',
                      color: '#ffffff',
                      transform: 'translateX(4px)',
                    }}>
                      B
                    </span>
                  </div>
                </button>

                {/* AIä»£ç ç”Ÿæˆå™¨æŒ‰é’® */}
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    const { scale: currentScale, panX, panY } = useBoardStore.getState();
                    setAIGeneratorPosition({ 
                      x: node.x * currentScale + panX + 100, 
                      y: node.y * currentScale + panY + 50 
                    });
                    setShowAIGenerator(true);
                    setShowActionMenu(false);
                  }}
                  style={{
                    position: 'absolute',
                    top: -32,
                    right: 164, // åœ¨ç¿»è½¬æŒ‰é’®å·¦ä¾§
                    width: 28,
                    height: 28,
                    borderRadius: 14,
                    border: `2px solid #ffffff`,
                    background: '#10b981', // ç»¿è‰²èƒŒæ™¯è¡¨ç¤ºAI
                    cursor: 'pointer',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    boxShadow: `0 3px 12px rgba(16,185,129,0.3)`, // ç»¿è‰²é˜´å½±
                    transition: 'all 0.3s ease',
                    animation: 'slideIn 0.2s ease-out 0.15s both',
                    zIndex: 996,
                  }}
                  onMouseEnter={(e) => {
                    e.currentTarget.style.transform = 'scale(1.1)';
                    e.currentTarget.style.boxShadow = '0 4px 16px rgba(16,185,129,0.4)';
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.transform = 'scale(1)';
                    e.currentTarget.style.boxShadow = '0 3px 12px rgba(16,185,129,0.3)';
                  }}
                  title="AIä»£ç ç”Ÿæˆå™¨"
                >
                  {/* AIæœºå™¨äººå›¾æ ‡ */}
                  <div style={{
                    fontSize: 14,
                    fontWeight: 'bold',
                    color: '#ffffff',
                  }}>
                    ğŸ¤–
                  </div>
                </button>
              </>
            )}
          </>
        )}
      </div>
      
      {/* æ ‡ç­¾æµ®å±‚ - æ˜¾ç¤ºåœ¨å¡ç‰‡å³ä¸‹è§’å¤–éƒ¨ */}
      {node.tags && node.tags.length > 0 && !node.editing && (
        <div style={{
          position: 'absolute',
          bottom: -20,
          right: 0,
          display: 'flex',
          alignItems: 'center',
          flexWrap: 'wrap',
          gap: 4,
          padding: '2px 6px',
          background: 'rgba(0,0,0,0.8)',
          borderRadius: 4,
          fontSize: 10,
          color: '#fff',
          maxWidth: '200px',
          zIndex: 1000,
          pointerEvents: 'auto',
        }}>
          {node.tags.map((tag, index) => (
            <span
              key={tag}
              style={{
                display: 'inline-flex',
                alignItems: 'center',
                cursor: 'pointer',
                padding: '1px 3px',
                borderRadius: 2,
                backgroundColor: 'rgba(255,255,255,0.2)',
                transition: 'all 0.2s ease',
                fontSize: 9,
              }}
              onClick={(e) => {
                e.stopPropagation();
                removeTag(tag);
              }}
              onMouseEnter={(e) => {
                e.currentTarget.style.backgroundColor = 'rgba(239, 68, 68, 0.6)';
              }}
              onMouseLeave={(e) => {
                e.currentTarget.style.backgroundColor = 'rgba(255,255,255,0.2)';
              }}
              title="ç‚¹å‡»åˆ é™¤æ ‡ç­¾"
            >
              {tag}
            </span>
          ))}
        </div>
      )}
      
      {/* ç¡®è®¤åˆ é™¤å¯¹è¯æ¡† */}
      {showDeleteModal && (
        <DeleteConfirmModal
          isOpen={showDeleteModal}
          nodeCount={1}
          onCancel={() => setShowDeleteModal(false)}
          onConfirm={handleConfirmDelete}
        />
      )}
      
      {/* é¢œè‰²é€‰æ‹©å™¨å¼¹å‡ºçª—å£ */}
      {showColorPicker && (
        <CardColorPicker
          position={colorPickerPosition}
          currentColor={isDarkMode ? node.darkBackgroundColor : node.lightBackgroundColor}
          frosted={!!node.frosted}
          onColorChange={handleColorChange}
          onFrostedChange={val => updateNode(node.id, { frosted: val })}
          onClose={() => setShowColorPicker(false)}
        />
      )}
      
      {/* AIä»£ç ç”Ÿæˆå™¨å¼¹å‡ºçª—å£ */}
      {showAIGenerator && (
        <AICodeGenerator
          isOpen={showAIGenerator}
          position={aiGeneratorPosition}
          onClose={() => setShowAIGenerator(false)}
        />
      )}
    </>
  );
};

export default NodeCard;
